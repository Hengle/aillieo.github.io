<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aillieo.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"EM0NG1L32X","apiKey":"862c62ca101f920300ddfebb30fcba33","indexName":"aillieo-collection","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Image是UGUI中最常用的组件之一，用于在UI中显示一个图片（Sprite），继承自MaskableGraphic，覆写了Graphic和MaskableGraphic的一些方法。同时实现了三个接口，ISerializationCallbackReceiver接收序列化和反序列化完成的回调，ILayoutElement作为自动布局元素，实现了计算自动布局尺寸的接口，ICanvasRaycast">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity3D UGUI 源码学习 Image">
<meta property="og:url" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/index.html">
<meta property="og:site_name" content="Aillieo Collection">
<meta property="og:description" content="Image是UGUI中最常用的组件之一，用于在UI中显示一个图片（Sprite），继承自MaskableGraphic，覆写了Graphic和MaskableGraphic的一些方法。同时实现了三个接口，ISerializationCallbackReceiver接收序列化和反序列化完成的回调，ILayoutElement作为自动布局元素，实现了计算自动布局尺寸的接口，ICanvasRaycast">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/type1.gif">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/padding.png">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/image.png">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/type2.gif">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/scratch.png">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/type3.gif">
<meta property="og:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/type4.gif">
<meta property="article:published_time" content="2018-07-20T15:54:13.000Z">
<meta property="article:modified_time" content="2020-07-09T16:06:33.067Z">
<meta property="article:author" content="Aillieo">
<meta property="article:tag" content="ugui">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="source code">
<meta property="article:tag" content="image">
<meta property="article:tag" content="sprite">
<meta property="article:tag" content="sliced">
<meta property="article:tag" content="filled">
<meta property="article:tag" content="tiled">
<meta property="article:tag" content="border">
<meta property="article:tag" content="padding">
<meta property="article:tag" content="inneruv">
<meta property="article:tag" content="outteruv">
<meta property="article:tag" content="MaskableGraphic">
<meta property="article:tag" content="ISerializationCallbackReceiver">
<meta property="article:tag" content="ILayoutElement">
<meta property="article:tag" content="ICanvasRaycastFilter">
<meta property="article:tag" content="vertex">
<meta property="article:tag" content="quad">
<meta property="article:tag" content="addquad">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/2018-07-20-unity-3d-ugui-source-code-10/type1.gif">

<link rel="canonical" href="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Unity3D UGUI 源码学习 Image | Aillieo Collection</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aillieo Collection</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">SUBTITLE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://aillieo.cn/post/2018-07-20-unity-3d-ugui-source-code-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Aillieo">
      <meta itemprop="description" content="PROGRAMMING | GAMES | DESIGN">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aillieo Collection">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Unity3D UGUI 源码学习 Image
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-20 23:54:13" itemprop="dateCreated datePublished" datetime="2018-07-20T23:54:13+08:00">2018-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-10 00:06:33" itemprop="dateModified" datetime="2020-07-10T00:06:33+08:00">2020-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity3D/" itemprop="url" rel="index"><span itemprop="name">Unity3D</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity3D/UGUI/" itemprop="url" rel="index"><span itemprop="name">UGUI</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>Image</code>是UGUI中最常用的组件之一，用于在UI中显示一个图片（Sprite），继承自<code>MaskableGraphic</code>，覆写了<code>Graphic</code>和<code>MaskableGraphic</code>的一些方法。同时实现了三个接口，<code>ISerializationCallbackReceiver</code>接收序列化和反序列化完成的回调，<code>ILayoutElement</code>作为自动布局元素，实现了计算自动布局尺寸的接口，<code>ICanvasRaycastFilter</code>实现了用于处理射线投射时过滤的方法，后边会一一详述。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter</span><br></pre></td></tr></table></figure>

<p>首先关注<code>Image</code>用于绘制和显示图像的逻辑。</p>
<h2 id="用于显示图像：MaskableGraphic"><a href="#用于显示图像：MaskableGraphic" class="headerlink" title="用于显示图像：MaskableGraphic"></a>用于显示图像：MaskableGraphic</h2><p>纹理图片绘制到UI层级树上，需要网格、纹理、shader等要素，结合之前<code>Graphic</code>的章节可知，UI树上绘制元素可以覆盖虚方法<code>UpdateGeometry()</code>和<code>UpdateMaterial()</code>来自行实现指定网格和材质的方法，以实现衍生组件类的绘制。所以此处也就讨论Geometry和<br>Material两部分：</p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p><code>Image</code>并没有直接覆<code>UpdateGeometry()</code>方法，而是覆写了生成网格的<code>OnPopulateMesh(...)</code>方法。对于一个长方形的纹理来说，其实需要两个三角形四个顶点即可完成绘制。满足这一简单需求的组件即是<code>RawImage</code>或者后边会提到的Image的<code>simple</code>类型。而对于<code>Image</code>，其中包含的是一个Sprite，可以提供更多更强大更复杂的功能，而不仅仅是显示矩形的纹理。</p>
<p><code>Image</code>有四种类型，对应的是四种绘制的方式，在<code>Image</code>类一开始就定义了枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Type</span><br><span class="line">&#123;</span><br><span class="line">    Simple,</span><br><span class="line">    Sliced,</span><br><span class="line">    Tiled,</span><br><span class="line">    Filled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用<code>Image</code>时会选择其中一种来使用。所以生成网格时也会分四种类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected override void OnPopulateMesh(VertexHelper toFill)</span><br><span class="line">&#123;</span><br><span class="line">    if (activeSprite &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        base.OnPopulateMesh(toFill);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (type)</span><br><span class="line">    &#123;</span><br><span class="line">        case Type.Simple:</span><br><span class="line">            GenerateSimpleSprite(toFill, m_PreserveAspect);</span><br><span class="line">            break;</span><br><span class="line">        case Type.Sliced:</span><br><span class="line">            GenerateSlicedSprite(toFill);</span><br><span class="line">            break;</span><br><span class="line">        case Type.Tiled:</span><br><span class="line">            GenerateTiledSprite(toFill);</span><br><span class="line">            break;</span><br><span class="line">        case Type.Filled:</span><br><span class="line">            GenerateFilledSprite(toFill, m_PreserveAspect);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据四种不同的类型，分别调用四种<code>GenerateXxxSprite()</code>：</p>
<h4 id="GenerateSimpleSprite"><a href="#GenerateSimpleSprite" class="headerlink" title="GenerateSimpleSprite"></a>GenerateSimpleSprite</h4><p>最简单的一种，也是<code>Image</code>默认的类型。Simple类型的<code>Image</code>示意图如下：</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/type1.gif" alt="alt text"></p>
<p>以下是<code>GenerateSimpleSprite()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void GenerateSimpleSprite(VertexHelper vh, bool lPreserveAspect)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4 v &#x3D; GetDrawingDimensions(lPreserveAspect);</span><br><span class="line">    var uv &#x3D; (activeSprite !&#x3D; null) ? Sprites.DataUtility.GetOuterUV(activeSprite) : Vector4.zero;</span><br><span class="line"></span><br><span class="line">    var color32 &#x3D; color;</span><br><span class="line">    vh.Clear();</span><br><span class="line">    vh.AddVert(new Vector3(v.x, v.y), color32, new Vector2(uv.x, uv.y));</span><br><span class="line">    vh.AddVert(new Vector3(v.x, v.w), color32, new Vector2(uv.x, uv.w));</span><br><span class="line">    vh.AddVert(new Vector3(v.z, v.w), color32, new Vector2(uv.z, uv.w));</span><br><span class="line">    vh.AddVert(new Vector3(v.z, v.y), color32, new Vector2(uv.z, uv.y));</span><br><span class="line"></span><br><span class="line">    vh.AddTriangle(0, 1, 2);</span><br><span class="line">    vh.AddTriangle(2, 3, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取顶点坐标<code>v</code>和顶点纹理坐标<code>uv</code>，填充到<code>vh</code>中。获取顶点坐标时直接使用<code>GetDrawingDimensions()</code>方法，而在获取纹理UV时，会调用静态方法<code>Sprites.DataUtility.GetOuterUV()</code>，如果没有指定sprite则返回四个0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Image&#39;s dimensions used for drawing. X &#x3D; left, Y &#x3D; bottom, Z &#x3D; right, W &#x3D; top.</span><br><span class="line">private Vector4 GetDrawingDimensions(bool shouldPreserveAspect)</span><br><span class="line">&#123;</span><br><span class="line">    var padding &#x3D; activeSprite &#x3D;&#x3D; null ? Vector4.zero : Sprites.DataUtility.GetPadding(activeSprite);</span><br><span class="line">    var size &#x3D; activeSprite &#x3D;&#x3D; null ? Vector2.zero : new Vector2(activeSprite.rect.width, activeSprite.rect.height);</span><br><span class="line"></span><br><span class="line">    Rect r &#x3D; GetPixelAdjustedRect();</span><br><span class="line">    &#x2F;&#x2F; Debug.Log(string.Format(&quot;r:&#123;2&#125;, size:&#123;0&#125;, padding:&#123;1&#125;&quot;, size, padding, r));</span><br><span class="line"></span><br><span class="line">    int spriteW &#x3D; Mathf.RoundToInt(size.x);</span><br><span class="line">    int spriteH &#x3D; Mathf.RoundToInt(size.y);</span><br><span class="line"></span><br><span class="line">    var v &#x3D; new Vector4(</span><br><span class="line">            padding.x &#x2F; spriteW,</span><br><span class="line">            padding.y &#x2F; spriteH,</span><br><span class="line">            (spriteW - padding.z) &#x2F; spriteW,</span><br><span class="line">            (spriteH - padding.w) &#x2F; spriteH);</span><br><span class="line"></span><br><span class="line">    if (shouldPreserveAspect &amp;&amp; size.sqrMagnitude &gt; 0.0f)</span><br><span class="line">    &#123;</span><br><span class="line">        var spriteRatio &#x3D; size.x &#x2F; size.y;</span><br><span class="line">        var rectRatio &#x3D; r.width &#x2F; r.height;</span><br><span class="line"></span><br><span class="line">        if (spriteRatio &gt; rectRatio)</span><br><span class="line">        &#123;</span><br><span class="line">            var oldHeight &#x3D; r.height;</span><br><span class="line">            r.height &#x3D; r.width * (1.0f &#x2F; spriteRatio);</span><br><span class="line">            r.y +&#x3D; (oldHeight - r.height) * rectTransform.pivot.y;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            var oldWidth &#x3D; r.width;</span><br><span class="line">            r.width &#x3D; r.height * spriteRatio;</span><br><span class="line">            r.x +&#x3D; (oldWidth - r.width) * rectTransform.pivot.x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v &#x3D; new Vector4(</span><br><span class="line">            r.x + r.width * v.x,</span><br><span class="line">            r.y + r.height * v.y,</span><br><span class="line">            r.x + r.width * v.z,</span><br><span class="line">            r.y + r.height * v.w</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GetDrawingDimensions()</code>用来获取<code>Image</code>的顶点坐标。传入一个布尔参数表示是否要为图片保持原有的宽高比。得到一个Vector4返回值，Vector4中的四个值分别是左、下、右、上边界的值（即x min、y min、x max和y max）。</p>
<p>其中用到的<code>Sprite</code>是<code>activeSprite</code>，其定义如下，如有<code>m_OverrideSprite</code>则使用，否则使用自身的<code>sprite</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Sprite activeSprite &#123; get &#123; return m_OverrideSprite !&#x3D; null ? m_OverrideSprite : sprite; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>这里还涉及到一个工具类，<code>Sprite.DataUtility</code>， 用于获取<code>Sprite</code>的数据。它包含有四个静态方法，与前边遇到的<code>GetPadding</code>相似都需要传入一个<code>Sprite</code>实例来获取它的信息：</p>
<ul>
<li><code>GetPadding</code>： 获取padding，如果sprite的纹理来自图集，那么当其被打到图集里时可能四边会被裁掉一些透明区域，padding即表示上下左右四边被裁掉的区域的大小，单位为像素；</li>
<li><code>GetInnerUV</code>： 获取内圈UV（纹理坐标）；</li>
<li><code>GetMinSize</code>： 获取最小宽高尺寸；</li>
<li><code>GetOuterUV</code>： 获取外圈UV（纹理坐标）；</li>
</ul>
<p>这些信息来自图集和<code>Sprite</code>的设置，Unity仅仅是提供了这一组接口。关于<code>padding</code>以及后边会提到的<code>Sprite</code>的<code>border</code>，可以参考下边的图：</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/padding.png" alt="alt text"></p>
<p>左侧是原始的png图片，周围白色的区域是透明底。右侧是裁剪后的图片，红色的线框是去除透明区域后的包络矩形，外边是所谓的<code>padding</code>。当使用此图片作为<code>Sprite</code>时，编辑器中显示的图片信息是这样的：</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/image.png" alt="alt text"></p>
<p><code>activeSprite.rect</code>此方法返回一个<code>Rect</code>，其中包含<code>Sprite</code>原始纹理的坐标与尺寸。还用到了一个方法<code>GetPixelAdjustedRect()</code>，定义在抽象类<code>Graphic</code>中，用于获取像素修正过的<code>Rect</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Rect GetPixelAdjustedRect()</span><br><span class="line">&#123;</span><br><span class="line">    if (!canvas || canvas.renderMode &#x3D;&#x3D; RenderMode.WorldSpace || canvas.scaleFactor &#x3D;&#x3D; 0.0f || !canvas.pixelPerfect)</span><br><span class="line">        return rectTransform.rect;</span><br><span class="line">    else</span><br><span class="line">        return RectTransformUtility.PixelAdjustRect(rectTransform, canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上边这些东西之外，全都是最简单的坐标计算了。这里的加加减减目的是为了消除padding的影响，把纹理坐标还原到（对应到）顶点坐标上，<code>size</code>是纹理的宽高尺寸（包含<code>padding</code>），<code>r</code>是<code>RectTransform</code>的尺寸。同时还处理了当<code>shouldPreserveAspect</code>时，根据宽度或高度中较小的值来调整另一个维度的尺寸，以确保绘制出来的<code>RectTransform</code>与<code>size</code>有相同的宽高比。</p>
<h4 id="GenerateSlicedSprite"><a href="#GenerateSlicedSprite" class="headerlink" title="GenerateSlicedSprite"></a>GenerateSlicedSprite</h4><p>这个应该是UI中Image使用的最多的类型了，常说的九宫格图片，Slice类型的<code>Image</code>示意图如下：</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/type2.gif" alt="alt text"></p>
<p>以下是<code>GenerateSlicedSprite()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">static readonly Vector2[] s_VertScratch &#x3D; new Vector2[4];</span><br><span class="line">static readonly Vector2[] s_UVScratch &#x3D; new Vector2[4];</span><br><span class="line"></span><br><span class="line">private void GenerateSlicedSprite(VertexHelper toFill)</span><br><span class="line">&#123;</span><br><span class="line">    if (!hasBorder)</span><br><span class="line">    &#123;</span><br><span class="line">        GenerateSimpleSprite(toFill, false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector4 outer, inner, padding, border;</span><br><span class="line"></span><br><span class="line">    if (activeSprite !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        outer &#x3D; Sprites.DataUtility.GetOuterUV(activeSprite);</span><br><span class="line">        inner &#x3D; Sprites.DataUtility.GetInnerUV(activeSprite);</span><br><span class="line">        padding &#x3D; Sprites.DataUtility.GetPadding(activeSprite);</span><br><span class="line">        border &#x3D; activeSprite.border;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        outer &#x3D; Vector4.zero;</span><br><span class="line">        inner &#x3D; Vector4.zero;</span><br><span class="line">        padding &#x3D; Vector4.zero;</span><br><span class="line">        border &#x3D; Vector4.zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect rect &#x3D; GetPixelAdjustedRect();</span><br><span class="line">    Vector4 adjustedBorders &#x3D; GetAdjustedBorders(border &#x2F; pixelsPerUnit, rect);</span><br><span class="line">    padding &#x3D; padding &#x2F; pixelsPerUnit;</span><br><span class="line"></span><br><span class="line">    s_VertScratch[0] &#x3D; new Vector2(padding.x, padding.y);</span><br><span class="line">    s_VertScratch[3] &#x3D; new Vector2(rect.width - padding.z, rect.height - padding.w);</span><br><span class="line"></span><br><span class="line">    s_VertScratch[1].x &#x3D; adjustedBorders.x;</span><br><span class="line">    s_VertScratch[1].y &#x3D; adjustedBorders.y;</span><br><span class="line"></span><br><span class="line">    s_VertScratch[2].x &#x3D; rect.width - adjustedBorders.z;</span><br><span class="line">    s_VertScratch[2].y &#x3D; rect.height - adjustedBorders.w;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 4; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s_VertScratch[i].x +&#x3D; rect.x;</span><br><span class="line">        s_VertScratch[i].y +&#x3D; rect.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_UVScratch[0] &#x3D; new Vector2(outer.x, outer.y);</span><br><span class="line">    s_UVScratch[1] &#x3D; new Vector2(inner.x, inner.y);</span><br><span class="line">    s_UVScratch[2] &#x3D; new Vector2(inner.z, inner.w);</span><br><span class="line">    s_UVScratch[3] &#x3D; new Vector2(outer.z, outer.w);</span><br><span class="line"></span><br><span class="line">    toFill.Clear();</span><br><span class="line"></span><br><span class="line">    for (int x &#x3D; 0; x &lt; 3; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        int x2 &#x3D; x + 1;</span><br><span class="line"></span><br><span class="line">        for (int y &#x3D; 0; y &lt; 3; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!m_FillCenter &amp;&amp; x &#x3D;&#x3D; 1 &amp;&amp; y &#x3D;&#x3D; 1)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            int y2 &#x3D; y + 1;</span><br><span class="line"></span><br><span class="line">            AddQuad(toFill,</span><br><span class="line">                new Vector2(s_VertScratch[x].x, s_VertScratch[y].y),</span><br><span class="line">                new Vector2(s_VertScratch[x2].x, s_VertScratch[y2].y),</span><br><span class="line">                color,</span><br><span class="line">                new Vector2(s_UVScratch[x].x, s_UVScratch[y].y),</span><br><span class="line">                new Vector2(s_UVScratch[x2].x, s_UVScratch[y2].y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比Simple类型的Sprite会稍稍复杂一些，用到了两个额外的Vector2数组来存储顶点坐标及纹理坐标。<code>hasBorder</code>的判断如下，其实是获取<code>activeSprite.border</code>并判断其是否有至少一个不为0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public bool hasBorder</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        if (activeSprite !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector4 v &#x3D; activeSprite.border;</span><br><span class="line">            return v.sqrMagnitude &gt; 0f;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>border</code>四边都是0时，则九宫格图会退化到最简单的图直接使用<code>GenerateSimpleSprite</code>来绘制。</p>
<p>对于带有<code>border</code>的Slice型<code>Image</code>，最多会绘制9个Quad（九宫格名字应该就这么来的），所以后边的工作就是在计算这9个Quad所对应的顶点坐标和UV。内圈外圈的纹理坐标前边说到了<code>Sprites.DataUtility</code>可以取到，<code>border</code>尺寸<code>Sprite</code>直接就能获得，最后不得不考虑的还有<code>padding</code>。有了这四个<code>Vector4</code>就可以来计算9个Quad的顶点和UV了。</p>
<p>这里还有一点值得注意。像素与单位的换算。此换算基于<code>Sprite</code>的<code>pixelsPerUnit</code>和<code>Canvas</code>的<code>referencePixelsPerUnit</code>属性，前者表示<code>Sprite</code>单位长度对应的像素数（像素密度），后者是一个参考值，表示默认的单位像素数。<code>Image</code>计算<code>pixelsPerUnit</code>时是将二者相除。当<code>pixelsPerUnit</code>和<code>referencePixelsPerUnit</code>相等时，<code>Image</code>会得到<code>pixelsPerUnit</code>为1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public float pixelsPerUnit</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        float spritePixelsPerUnit &#x3D; 100;</span><br><span class="line">        if (activeSprite)</span><br><span class="line">            spritePixelsPerUnit &#x3D; activeSprite.pixelsPerUnit;</span><br><span class="line"></span><br><span class="line">        float referencePixelsPerUnit &#x3D; 100;</span><br><span class="line">        if (canvas)</span><br><span class="line">            referencePixelsPerUnit &#x3D; canvas.referencePixelsPerUnit;</span><br><span class="line"></span><br><span class="line">        return spritePixelsPerUnit &#x2F; referencePixelsPerUnit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>GetAdjustedBorders</code>对<code>border</code>的特殊情况处理，即当Image尺寸小于两侧border之和的时候，会对对应轴向的border做一个整体的缩放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vector4 GetAdjustedBorders(Vector4 border, Rect rect)</span><br><span class="line">&#123;</span><br><span class="line">    for (int axis &#x3D; 0; axis &lt;&#x3D; 1; axis++)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; If the rect is smaller than the combined borders, then there&#39;s not room for the borders at their normal size.</span><br><span class="line">        &#x2F;&#x2F; In order to avoid artefacts with overlapping borders, we scale the borders down to fit.</span><br><span class="line">        float combinedBorders &#x3D; border[axis] + border[axis + 2];</span><br><span class="line">        if (rect.size[axis] &lt; combinedBorders &amp;&amp; combinedBorders !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            float borderScaleRatio &#x3D; rect.size[axis] &#x2F; combinedBorders;</span><br><span class="line">            border[axis] *&#x3D; borderScaleRatio;</span><br><span class="line">            border[axis + 2] *&#x3D; borderScaleRatio;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return border;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是重点部分了，填充<code>s_VertScratch</code>和<code>s_UVScratch</code>，摘录之前的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s_VertScratch[0] &#x3D; new Vector2(padding.x, padding.y);</span><br><span class="line">s_VertScratch[3] &#x3D; new Vector2(rect.width - padding.z, rect.height - padding.w);</span><br><span class="line"></span><br><span class="line">s_VertScratch[1].x &#x3D; adjustedBorders.x;</span><br><span class="line">s_VertScratch[1].y &#x3D; adjustedBorders.y;</span><br><span class="line"></span><br><span class="line">s_VertScratch[2].x &#x3D; rect.width - adjustedBorders.z;</span><br><span class="line">s_VertScratch[2].y &#x3D; rect.height - adjustedBorders.w;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    s_VertScratch[i].x +&#x3D; rect.x;</span><br><span class="line">    s_VertScratch[i].y +&#x3D; rect.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s_UVScratch[0] &#x3D; new Vector2(outer.x, outer.y);</span><br><span class="line">s_UVScratch[1] &#x3D; new Vector2(inner.x, inner.y);</span><br><span class="line">s_UVScratch[2] &#x3D; new Vector2(inner.z, inner.w);</span><br><span class="line">s_UVScratch[3] &#x3D; new Vector2(outer.z, outer.w);</span><br></pre></td></tr></table></figure>

<p>具体可参看下图，还是前边提到的那张图片，图上<code>p0</code>到<code>p3</code>共四个点，分别对应的是填充后的<code>s_VertScratch</code>和<code>s_UVScratch</code>下标0到3的四个点的位置信息。可以看出当图片尺寸变化时，<code>rect</code>的尺寸会随之变化，但<code>border</code>的值是不变的，<code>s_VertScratch[0]</code>和<code>s_VertScratch[1]</code>不会变化，而<code>s_VertScratch[2]</code>和<code>s_VertScratch[3]</code>会偏移变化，进而保证只有中间的区域被拉伸或缩小。</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/scratch.png" alt="alt text"></p>
<p>在两个数组里边保存好顶点坐标和纹理的UV之后，就开始绘制了，共分为9个四边形（Quad），使用两层遍历。<code>Image</code>里边又封装了一层<code>AddQuad</code>的方法，直接传入两点坐标即可向<code>VertexHelper</code>中添加两个三角形（一个四边形）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void AddQuad(VertexHelper vertexHelper, Vector2 posMin, Vector2 posMax, Color32 color, Vector2 uvMin, Vector2 uvMax)</span><br><span class="line">&#123;</span><br><span class="line">    int startIndex &#x3D; vertexHelper.currentVertCount;</span><br><span class="line"></span><br><span class="line">    vertexHelper.AddVert(new Vector3(posMin.x, posMin.y, 0), color, new Vector2(uvMin.x, uvMin.y));</span><br><span class="line">    vertexHelper.AddVert(new Vector3(posMin.x, posMax.y, 0), color, new Vector2(uvMin.x, uvMax.y));</span><br><span class="line">    vertexHelper.AddVert(new Vector3(posMax.x, posMax.y, 0), color, new Vector2(uvMax.x, uvMax.y));</span><br><span class="line">    vertexHelper.AddVert(new Vector3(posMax.x, posMin.y, 0), color, new Vector2(uvMax.x, uvMin.y));</span><br><span class="line"></span><br><span class="line">    vertexHelper.AddTriangle(startIndex, startIndex + 1, startIndex + 2);</span><br><span class="line">    vertexHelper.AddTriangle(startIndex + 2, startIndex + 3, startIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GenerateTiledSprite"><a href="#GenerateTiledSprite" class="headerlink" title="GenerateTiledSprite"></a>GenerateTiledSprite</h4><p>另一种常用的<code>Image</code>类型是Tiled。当<code>Image</code>尺寸大于<code>Sprite</code>的尺寸时，会用平铺的方式填充。注意对于带有<code>border</code>的<code>Sprite</code>，平铺时会保留<code>border</code>的部分，只将<code>Sprite</code>中<code>border</code>以外的纹理做平铺（<code>border</code>中除了四个角上的区域以外会沿着单个方向平铺）。Tiled类型的<code>Image</code>示意图如下：</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/type3.gif" alt="alt text"></p>
<p>以下是<code>GenerateTiledSprite()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line">void GenerateTiledSprite(VertexHelper toFill)</span><br><span class="line">&#123;</span><br><span class="line">    Vector4 outer, inner, border;</span><br><span class="line">    Vector2 spriteSize;</span><br><span class="line"></span><br><span class="line">    if (activeSprite !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        outer &#x3D; Sprites.DataUtility.GetOuterUV(activeSprite);</span><br><span class="line">        inner &#x3D; Sprites.DataUtility.GetInnerUV(activeSprite);</span><br><span class="line">        border &#x3D; activeSprite.border;</span><br><span class="line">        spriteSize &#x3D; activeSprite.rect.size;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        outer &#x3D; Vector4.zero;</span><br><span class="line">        inner &#x3D; Vector4.zero;</span><br><span class="line">        border &#x3D; Vector4.zero;</span><br><span class="line">        spriteSize &#x3D; Vector2.one * 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect rect &#x3D; GetPixelAdjustedRect();</span><br><span class="line">    float tileWidth &#x3D; (spriteSize.x - border.x - border.z) &#x2F; pixelsPerUnit;</span><br><span class="line">    float tileHeight &#x3D; (spriteSize.y - border.y - border.w) &#x2F; pixelsPerUnit;</span><br><span class="line">    border &#x3D; GetAdjustedBorders(border &#x2F; pixelsPerUnit, rect);</span><br><span class="line"></span><br><span class="line">    var uvMin &#x3D; new Vector2(inner.x, inner.y);</span><br><span class="line">    var uvMax &#x3D; new Vector2(inner.z, inner.w);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Min to max max range for tiled region in coordinates relative to lower left corner.</span><br><span class="line">    float xMin &#x3D; border.x;</span><br><span class="line">    float xMax &#x3D; rect.width - border.z;</span><br><span class="line">    float yMin &#x3D; border.y;</span><br><span class="line">    float yMax &#x3D; rect.height - border.w;</span><br><span class="line"></span><br><span class="line">    toFill.Clear();</span><br><span class="line">    var clipped &#x3D; uvMax;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if either width is zero we cant tile so just assume it was the full width.</span><br><span class="line">    if (tileWidth &lt;&#x3D; 0)</span><br><span class="line">        tileWidth &#x3D; xMax - xMin;</span><br><span class="line"></span><br><span class="line">    if (tileHeight &lt;&#x3D; 0)</span><br><span class="line">        tileHeight &#x3D; yMax - yMin;</span><br><span class="line"></span><br><span class="line">    if (activeSprite !&#x3D; null &amp;&amp; (hasBorder || activeSprite.packed || activeSprite.texture.wrapMode !&#x3D; TextureWrapMode.Repeat))</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Sprite has border, or is not in repeat mode, or cannot be repeated because of packing.</span><br><span class="line">        &#x2F;&#x2F; We cannot use texture tiling so we will generate a mesh of quads to tile the texture.</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Evaluate how many vertices we will generate. Limit this number to something sane,</span><br><span class="line">        &#x2F;&#x2F; especially since meshes can not have more than 65000 vertices.</span><br><span class="line"></span><br><span class="line">        int nTilesW &#x3D; 0;</span><br><span class="line">        int nTilesH &#x3D; 0;</span><br><span class="line">        if (m_FillCenter)</span><br><span class="line">        &#123;</span><br><span class="line">            nTilesW &#x3D; (int)Math.Ceiling((xMax - xMin) &#x2F; tileWidth);</span><br><span class="line">            nTilesH &#x3D; (int)Math.Ceiling((yMax - yMin) &#x2F; tileHeight);</span><br><span class="line"></span><br><span class="line">            int nVertices &#x3D; 0;</span><br><span class="line">            if (hasBorder)</span><br><span class="line">            &#123;</span><br><span class="line">                nVertices &#x3D; (nTilesW + 2) * (nTilesH + 2) * 4; &#x2F;&#x2F; 4 vertices per tile</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                nVertices &#x3D; nTilesW * nTilesH * 4; &#x2F;&#x2F; 4 vertices per tile</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (nVertices &gt; 65000)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;Too many sprite tiles on Image \&quot;&quot; + name + &quot;\&quot;. The tile size will be increased. To remove the limit on the number of tiles, convert the Sprite to an Advanced texture, remove the borders, clear the Packing tag and set the Wrap mode to Repeat.&quot;, this);</span><br><span class="line"></span><br><span class="line">                double maxTiles &#x3D; 65000.0 &#x2F; 4.0; &#x2F;&#x2F; Max number of vertices is 65000; 4 vertices per tile.</span><br><span class="line">                double imageRatio;</span><br><span class="line">                if (hasBorder)</span><br><span class="line">                &#123;</span><br><span class="line">                    imageRatio &#x3D; (nTilesW + 2.0) &#x2F; (nTilesH + 2.0);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    imageRatio &#x3D; (double)nTilesW &#x2F; nTilesH;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                double targetTilesW &#x3D; Math.Sqrt(maxTiles &#x2F; imageRatio);</span><br><span class="line">                double targetTilesH &#x3D; targetTilesW * imageRatio;</span><br><span class="line">                if (hasBorder)</span><br><span class="line">                &#123;</span><br><span class="line">                    targetTilesW -&#x3D; 2;</span><br><span class="line">                    targetTilesH -&#x3D; 2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nTilesW &#x3D; (int)Math.Floor(targetTilesW);</span><br><span class="line">                nTilesH &#x3D; (int)Math.Floor(targetTilesH);</span><br><span class="line">                tileWidth &#x3D; (xMax - xMin) &#x2F; nTilesW;</span><br><span class="line">                tileHeight &#x3D; (yMax - yMin) &#x2F; nTilesH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (hasBorder)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Texture on the border is repeated only in one direction.</span><br><span class="line">                nTilesW &#x3D; (int)Math.Ceiling((xMax - xMin) &#x2F; tileWidth);</span><br><span class="line">                nTilesH &#x3D; (int)Math.Ceiling((yMax - yMin) &#x2F; tileHeight);</span><br><span class="line">                int nVertices &#x3D; (nTilesH + nTilesW + 2 &#x2F;*corners*&#x2F;) * 2 &#x2F;*sides*&#x2F; * 4 &#x2F;*vertices per tile*&#x2F;;</span><br><span class="line">                if (nVertices &gt; 65000)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.LogError(&quot;Too many sprite tiles on Image \&quot;&quot; + name + &quot;\&quot;. The tile size will be increased. To remove the limit on the number of tiles, convert the Sprite to an Advanced texture, remove the borders, clear the Packing tag and set the Wrap mode to Repeat.&quot;, this);</span><br><span class="line"></span><br><span class="line">                    double maxTiles &#x3D; 65000.0 &#x2F; 4.0; &#x2F;&#x2F; Max number of vertices is 65000; 4 vertices per tile.</span><br><span class="line">                    double imageRatio &#x3D; (double)nTilesW &#x2F; nTilesH;</span><br><span class="line">                    double targetTilesW &#x3D; (maxTiles - 4 &#x2F;*corners*&#x2F;) &#x2F; (2 * (1.0 + imageRatio));</span><br><span class="line">                    double targetTilesH &#x3D; targetTilesW * imageRatio;</span><br><span class="line"></span><br><span class="line">                    nTilesW &#x3D; (int)Math.Floor(targetTilesW);</span><br><span class="line">                    nTilesH &#x3D; (int)Math.Floor(targetTilesH);</span><br><span class="line">                    tileWidth &#x3D; (xMax - xMin) &#x2F; nTilesW;</span><br><span class="line">                    tileHeight &#x3D; (yMax - yMin) &#x2F; nTilesH;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                nTilesH &#x3D; nTilesW &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (m_FillCenter)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO: we could share vertices between quads. If vertex sharing is implemented. update the computation for the number of vertices accordingly.</span><br><span class="line">            for (int j &#x3D; 0; j &lt; nTilesH; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                float y1 &#x3D; yMin + j * tileHeight;</span><br><span class="line">                float y2 &#x3D; yMin + (j + 1) * tileHeight;</span><br><span class="line">                if (y2 &gt; yMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    clipped.y &#x3D; uvMin.y + (uvMax.y - uvMin.y) * (yMax - y1) &#x2F; (y2 - y1);</span><br><span class="line">                    y2 &#x3D; yMax;</span><br><span class="line">                &#125;</span><br><span class="line">                clipped.x &#x3D; uvMax.x;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; nTilesW; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    float x1 &#x3D; xMin + i * tileWidth;</span><br><span class="line">                    float x2 &#x3D; xMin + (i + 1) * tileWidth;</span><br><span class="line">                    if (x2 &gt; xMax)</span><br><span class="line">                    &#123;</span><br><span class="line">                        clipped.x &#x3D; uvMin.x + (uvMax.x - uvMin.x) * (xMax - x1) &#x2F; (x2 - x1);</span><br><span class="line">                        x2 &#x3D; xMax;</span><br><span class="line">                    &#125;</span><br><span class="line">                    AddQuad(toFill, new Vector2(x1, y1) + rect.position, new Vector2(x2, y2) + rect.position, color, uvMin, clipped);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasBorder)</span><br><span class="line">        &#123;</span><br><span class="line">            clipped &#x3D; uvMax;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; nTilesH; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                float y1 &#x3D; yMin + j * tileHeight;</span><br><span class="line">                float y2 &#x3D; yMin + (j + 1) * tileHeight;</span><br><span class="line">                if (y2 &gt; yMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    clipped.y &#x3D; uvMin.y + (uvMax.y - uvMin.y) * (yMax - y1) &#x2F; (y2 - y1);</span><br><span class="line">                    y2 &#x3D; yMax;</span><br><span class="line">                &#125;</span><br><span class="line">                AddQuad(toFill,</span><br><span class="line">                    new Vector2(0, y1) + rect.position,</span><br><span class="line">                    new Vector2(xMin, y2) + rect.position,</span><br><span class="line">                    color,</span><br><span class="line">                    new Vector2(outer.x, uvMin.y),</span><br><span class="line">                    new Vector2(uvMin.x, clipped.y));</span><br><span class="line">                AddQuad(toFill,</span><br><span class="line">                    new Vector2(xMax, y1) + rect.position,</span><br><span class="line">                    new Vector2(rect.width, y2) + rect.position,</span><br><span class="line">                    color,</span><br><span class="line">                    new Vector2(uvMax.x, uvMin.y),</span><br><span class="line">                    new Vector2(outer.z, clipped.y));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Bottom and top tiled border</span><br><span class="line">            clipped &#x3D; uvMax;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; nTilesW; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                float x1 &#x3D; xMin + i * tileWidth;</span><br><span class="line">                float x2 &#x3D; xMin + (i + 1) * tileWidth;</span><br><span class="line">                if (x2 &gt; xMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    clipped.x &#x3D; uvMin.x + (uvMax.x - uvMin.x) * (xMax - x1) &#x2F; (x2 - x1);</span><br><span class="line">                    x2 &#x3D; xMax;</span><br><span class="line">                &#125;</span><br><span class="line">                AddQuad(toFill,</span><br><span class="line">                    new Vector2(x1, 0) + rect.position,</span><br><span class="line">                    new Vector2(x2, yMin) + rect.position,</span><br><span class="line">                    color,</span><br><span class="line">                    new Vector2(uvMin.x, outer.y),</span><br><span class="line">                    new Vector2(clipped.x, uvMin.y));</span><br><span class="line">                AddQuad(toFill,</span><br><span class="line">                    new Vector2(x1, yMax) + rect.position,</span><br><span class="line">                    new Vector2(x2, rect.height) + rect.position,</span><br><span class="line">                    color,</span><br><span class="line">                    new Vector2(uvMin.x, uvMax.y),</span><br><span class="line">                    new Vector2(clipped.x, outer.w));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Corners</span><br><span class="line">            AddQuad(toFill,</span><br><span class="line">                new Vector2(0, 0) + rect.position,</span><br><span class="line">                new Vector2(xMin, yMin) + rect.position,</span><br><span class="line">                color,</span><br><span class="line">                new Vector2(outer.x, outer.y),</span><br><span class="line">                new Vector2(uvMin.x, uvMin.y));</span><br><span class="line">            AddQuad(toFill,</span><br><span class="line">                new Vector2(xMax, 0) + rect.position,</span><br><span class="line">                new Vector2(rect.width, yMin) + rect.position,</span><br><span class="line">                color,</span><br><span class="line">                new Vector2(uvMax.x, outer.y),</span><br><span class="line">                new Vector2(outer.z, uvMin.y));</span><br><span class="line">            AddQuad(toFill,</span><br><span class="line">                new Vector2(0, yMax) + rect.position,</span><br><span class="line">                new Vector2(xMin, rect.height) + rect.position,</span><br><span class="line">                color,</span><br><span class="line">                new Vector2(outer.x, uvMax.y),</span><br><span class="line">                new Vector2(uvMin.x, outer.w));</span><br><span class="line">            AddQuad(toFill,</span><br><span class="line">                new Vector2(xMax, yMax) + rect.position,</span><br><span class="line">                new Vector2(rect.width, rect.height) + rect.position,</span><br><span class="line">                color,</span><br><span class="line">                new Vector2(uvMax.x, uvMax.y),</span><br><span class="line">                new Vector2(outer.z, outer.w));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Texture has no border, is in repeat mode and not packed. Use texture tiling.</span><br><span class="line">        Vector2 uvScale &#x3D; new Vector2((xMax - xMin) &#x2F; tileWidth, (yMax - yMin) &#x2F; tileHeight);</span><br><span class="line"></span><br><span class="line">        if (m_FillCenter)</span><br><span class="line">        &#123;</span><br><span class="line">            AddQuad(toFill, new Vector2(xMin, yMin) + rect.position, new Vector2(xMax, yMax) + rect.position, color, Vector2.Scale(uvMin, uvScale), Vector2.Scale(uvMax, uvScale));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先也是计算了一系列的参数，<code>xMin</code>、<code>xMax</code>、<code>yMin</code>和<code>yMax</code>保存的是去除<code>border</code>以外的部分的待填充区域，<code>uvMin</code>和<code>uvMax</code>也保存的是去除<code>border</code>之后的纹理坐标。在绘制时，分为两种情况：</p>
<ul>
<li><p>Sprite有border、纹理不是Repeat模式、或者Sprite因为打合图等原因导致不能重复纹理来平铺；</p>
</li>
<li><p>除了上边以外的情况，可以直接用纹理填充；</p>
</li>
</ul>
<p>因此第二种情况会比较简单，直接绘制一个Quad，设置纹理坐标即可。比较复杂的是第一种情况，<code>GenerateTiledSprite(...)</code>中大部分代码是用于处理第一种情况的，绘制时需要分解为多个Quad，包括<code>border</code>部分及中心部分。各个Quad同样是需要计算顶点坐标和UV。</p>
<p>使用<code>m_FillCenter</code>来判断是否绘制中心区域，根据是否<code>hasBorder</code>来判断是否要处理border区域的逻辑。在计算各Quad的信息之前，首先确定参数<code>tileWidth</code>和<code>tileHeight</code>，默认取<code>Sprite</code>中心区域宽高的像素数，如果是0则表示宽度或高度为整个Image中心区域的宽度或高度，接下来计算Quad数量（顶点的数量），如果顶点数量大于65000，则会输出错误，并强制修改<code>tileWidth</code>和<code>tileHeight</code>，增大每个tile（Quad）的尺寸，从而减少tile的数量，进而减少顶点数，以确保顶点数目不会超过65000。</p>
<p>有了正确的<code>tileWidth</code>和<code>tileHeight</code>之后，同样是依照<code>m_FillCenter</code>和<code>hasBorder</code>来分别处理中心和边界区域的Quad。首先是中心区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if (m_FillCenter)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: we could share vertices between quads. If vertex sharing is implemented. update the computation for the number of vertices accordingly.</span><br><span class="line">    for (int j &#x3D; 0; j &lt; nTilesH; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        float y1 &#x3D; yMin + j * tileHeight;</span><br><span class="line">        float y2 &#x3D; yMin + (j + 1) * tileHeight;</span><br><span class="line">        if (y2 &gt; yMax)</span><br><span class="line">        &#123;</span><br><span class="line">            clipped.y &#x3D; uvMin.y + (uvMax.y - uvMin.y) * (yMax - y1) &#x2F; (y2 - y1);</span><br><span class="line">            y2 &#x3D; yMax;</span><br><span class="line">        &#125;</span><br><span class="line">        clipped.x &#x3D; uvMax.x;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nTilesW; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            float x1 &#x3D; xMin + i * tileWidth;</span><br><span class="line">            float x2 &#x3D; xMin + (i + 1) * tileWidth;</span><br><span class="line">            if (x2 &gt; xMax)</span><br><span class="line">            &#123;</span><br><span class="line">                clipped.x &#x3D; uvMin.x + (uvMax.x - uvMin.x) * (xMax - x1) &#x2F; (x2 - x1);</span><br><span class="line">                x2 &#x3D; xMax;</span><br><span class="line">            &#125;</span><br><span class="line">            AddQuad(toFill, new Vector2(x1, y1) + rect.position, new Vector2(x2, y2) + rect.position, color, uvMin, clipped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有什么复杂逻辑，从下到上、从左到右填充，注意有一个变量<code>clipped</code>，记录的是最上一行及最右一列的位于右上角的纹理坐标。最上一行和最右一列的Quad可能不会是完整的Sprite的核心区域，因此需要绘制时需要与<code>yMax</code>、<code>xMax</code>作比较，并且记录纹理坐标<code>clipped</code>。接下来是边界部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">if (hasBorder)</span><br><span class="line">&#123;</span><br><span class="line">    clipped &#x3D; uvMax;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; nTilesH; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        float y1 &#x3D; yMin + j * tileHeight;</span><br><span class="line">        float y2 &#x3D; yMin + (j + 1) * tileHeight;</span><br><span class="line">        if (y2 &gt; yMax)</span><br><span class="line">        &#123;</span><br><span class="line">            clipped.y &#x3D; uvMin.y + (uvMax.y - uvMin.y) * (yMax - y1) &#x2F; (y2 - y1);</span><br><span class="line">            y2 &#x3D; yMax;</span><br><span class="line">        &#125;</span><br><span class="line">        AddQuad(toFill,</span><br><span class="line">            new Vector2(0, y1) + rect.position,</span><br><span class="line">            new Vector2(xMin, y2) + rect.position,</span><br><span class="line">            color,</span><br><span class="line">            new Vector2(outer.x, uvMin.y),</span><br><span class="line">            new Vector2(uvMin.x, clipped.y));</span><br><span class="line">        AddQuad(toFill,</span><br><span class="line">            new Vector2(xMax, y1) + rect.position,</span><br><span class="line">            new Vector2(rect.width, y2) + rect.position,</span><br><span class="line">            color,</span><br><span class="line">            new Vector2(uvMax.x, uvMin.y),</span><br><span class="line">            new Vector2(outer.z, clipped.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Bottom and top tiled border</span><br><span class="line">    clipped &#x3D; uvMax;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nTilesW; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        float x1 &#x3D; xMin + i * tileWidth;</span><br><span class="line">        float x2 &#x3D; xMin + (i + 1) * tileWidth;</span><br><span class="line">        if (x2 &gt; xMax)</span><br><span class="line">        &#123;</span><br><span class="line">            clipped.x &#x3D; uvMin.x + (uvMax.x - uvMin.x) * (xMax - x1) &#x2F; (x2 - x1);</span><br><span class="line">            x2 &#x3D; xMax;</span><br><span class="line">        &#125;</span><br><span class="line">        AddQuad(toFill,</span><br><span class="line">            new Vector2(x1, 0) + rect.position,</span><br><span class="line">            new Vector2(x2, yMin) + rect.position,</span><br><span class="line">            color,</span><br><span class="line">            new Vector2(uvMin.x, outer.y),</span><br><span class="line">            new Vector2(clipped.x, uvMin.y));</span><br><span class="line">        AddQuad(toFill,</span><br><span class="line">            new Vector2(x1, yMax) + rect.position,</span><br><span class="line">            new Vector2(x2, rect.height) + rect.position,</span><br><span class="line">            color,</span><br><span class="line">            new Vector2(uvMin.x, uvMax.y),</span><br><span class="line">            new Vector2(clipped.x, outer.w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Corners</span><br><span class="line">    AddQuad(toFill,</span><br><span class="line">        new Vector2(0, 0) + rect.position,</span><br><span class="line">        new Vector2(xMin, yMin) + rect.position,</span><br><span class="line">        color,</span><br><span class="line">        new Vector2(outer.x, outer.y),</span><br><span class="line">        new Vector2(uvMin.x, uvMin.y));</span><br><span class="line">    AddQuad(toFill,</span><br><span class="line">        new Vector2(xMax, 0) + rect.position,</span><br><span class="line">        new Vector2(rect.width, yMin) + rect.position,</span><br><span class="line">        color,</span><br><span class="line">        new Vector2(uvMax.x, outer.y),</span><br><span class="line">        new Vector2(outer.z, uvMin.y));</span><br><span class="line">    AddQuad(toFill,</span><br><span class="line">        new Vector2(0, yMax) + rect.position,</span><br><span class="line">        new Vector2(xMin, rect.height) + rect.position,</span><br><span class="line">        color,</span><br><span class="line">        new Vector2(outer.x, uvMax.y),</span><br><span class="line">        new Vector2(uvMin.x, outer.w));</span><br><span class="line">    AddQuad(toFill,</span><br><span class="line">        new Vector2(xMax, yMax) + rect.position,</span><br><span class="line">        new Vector2(rect.width, rect.height) + rect.position,</span><br><span class="line">        color,</span><br><span class="line">        new Vector2(uvMax.x, uvMax.y),</span><br><span class="line">        new Vector2(outer.z, outer.w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先绘制左右两边的边界，再绘制上下的边界，最后是四个角。每轮绘制之前会重置<code>clipped</code>为<code>uvMax</code>，同样每列的最后一个和每行的最后一个需要与<code>yMax</code>和<code>xMax</code>比较，并修改<code>clipped</code>的值。最后是绘制四个角，会用到<code>outer</code>中保留的纹理坐标。</p>
<h4 id="GenerateFilledSprite"><a href="#GenerateFilledSprite" class="headerlink" title="GenerateFilledSprite"></a>GenerateFilledSprite</h4><p>Image的最后一种类型是filled，常用来做进度条等UI组件。这一类型的Image中又可分为多种填充方式，定义有枚举类型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum FillMethod</span><br><span class="line">&#123;</span><br><span class="line">    Horizontal,</span><br><span class="line">    Vertical,</span><br><span class="line">    Radial90,</span><br><span class="line">    Radial180,</span><br><span class="line">    Radial360,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与指向对应的，各种填充类型又可以定义多种不同的填充起点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public enum OriginHorizontal</span><br><span class="line">&#123;</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum OriginVertical</span><br><span class="line">&#123;</span><br><span class="line">    Bottom,</span><br><span class="line">    Top,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum Origin90</span><br><span class="line">&#123;</span><br><span class="line">    BottomLeft,</span><br><span class="line">    TopLeft,</span><br><span class="line">    TopRight,</span><br><span class="line">    BottomRight,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum Origin180</span><br><span class="line">&#123;</span><br><span class="line">    Bottom,</span><br><span class="line">    Left,</span><br><span class="line">    Top,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum Origin360</span><br><span class="line">&#123;</span><br><span class="line">    Bottom,</span><br><span class="line">    Right,</span><br><span class="line">    Top,</span><br><span class="line">    Left,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中一种比较复杂的Filled类型的<code>Image</code>，360度填充（<code>Radial360</code>），其示意图如下：</p>
<p><img src="2018-07-20-unity-3d-ugui-source-code-10/type4.gif" alt="alt text"></p>
<p>接下来看函数<code>GenerateFilledSprite(...)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">static readonly Vector3[] s_Xy &#x3D; new Vector3[4];</span><br><span class="line">static readonly Vector3[] s_Uv &#x3D; new Vector3[4];</span><br><span class="line">void GenerateFilledSprite(VertexHelper toFill, bool preserveAspect)</span><br><span class="line">&#123;</span><br><span class="line">    toFill.Clear();</span><br><span class="line"></span><br><span class="line">    if (m_FillAmount &lt; 0.001f)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    Vector4 v &#x3D; GetDrawingDimensions(preserveAspect);</span><br><span class="line">    Vector4 outer &#x3D; activeSprite !&#x3D; null ? Sprites.DataUtility.GetOuterUV(activeSprite) : Vector4.zero;</span><br><span class="line">    UIVertex uiv &#x3D; UIVertex.simpleVert;</span><br><span class="line">    uiv.color &#x3D; color;</span><br><span class="line"></span><br><span class="line">    float tx0 &#x3D; outer.x;</span><br><span class="line">    float ty0 &#x3D; outer.y;</span><br><span class="line">    float tx1 &#x3D; outer.z;</span><br><span class="line">    float ty1 &#x3D; outer.w;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Horizontal and vertical filled sprites are simple -- just end the Image prematurely</span><br><span class="line">    if (m_FillMethod &#x3D;&#x3D; FillMethod.Horizontal || m_FillMethod &#x3D;&#x3D; FillMethod.Vertical)</span><br><span class="line">    &#123;</span><br><span class="line">        if (fillMethod &#x3D;&#x3D; FillMethod.Horizontal)</span><br><span class="line">        &#123;</span><br><span class="line">            float fill &#x3D; (tx1 - tx0) * m_FillAmount;</span><br><span class="line"></span><br><span class="line">            if (m_FillOrigin &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                v.x &#x3D; v.z - (v.z - v.x) * m_FillAmount;</span><br><span class="line">                tx0 &#x3D; tx1 - fill;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                v.z &#x3D; v.x + (v.z - v.x) * m_FillAmount;</span><br><span class="line">                tx1 &#x3D; tx0 + fill;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (fillMethod &#x3D;&#x3D; FillMethod.Vertical)</span><br><span class="line">        &#123;</span><br><span class="line">            float fill &#x3D; (ty1 - ty0) * m_FillAmount;</span><br><span class="line"></span><br><span class="line">            if (m_FillOrigin &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                v.y &#x3D; v.w - (v.w - v.y) * m_FillAmount;</span><br><span class="line">                ty0 &#x3D; ty1 - fill;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                v.w &#x3D; v.y + (v.w - v.y) * m_FillAmount;</span><br><span class="line">                ty1 &#x3D; ty0 + fill;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_Xy[0] &#x3D; new Vector2(v.x, v.y);</span><br><span class="line">    s_Xy[1] &#x3D; new Vector2(v.x, v.w);</span><br><span class="line">    s_Xy[2] &#x3D; new Vector2(v.z, v.w);</span><br><span class="line">    s_Xy[3] &#x3D; new Vector2(v.z, v.y);</span><br><span class="line"></span><br><span class="line">    s_Uv[0] &#x3D; new Vector2(tx0, ty0);</span><br><span class="line">    s_Uv[1] &#x3D; new Vector2(tx0, ty1);</span><br><span class="line">    s_Uv[2] &#x3D; new Vector2(tx1, ty1);</span><br><span class="line">    s_Uv[3] &#x3D; new Vector2(tx1, ty0);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        if (m_FillAmount &lt; 1f &amp;&amp; m_FillMethod !&#x3D; FillMethod.Horizontal &amp;&amp; m_FillMethod !&#x3D; FillMethod.Vertical)</span><br><span class="line">        &#123;</span><br><span class="line">            if (fillMethod &#x3D;&#x3D; FillMethod.Radial90)</span><br><span class="line">            &#123;</span><br><span class="line">                if (RadialCut(s_Xy, s_Uv, m_FillAmount, m_FillClockwise, m_FillOrigin))</span><br><span class="line">                    AddQuad(toFill, s_Xy, color, s_Uv);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (fillMethod &#x3D;&#x3D; FillMethod.Radial180)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int side &#x3D; 0; side &lt; 2; ++side)</span><br><span class="line">                &#123;</span><br><span class="line">                    float fx0, fx1, fy0, fy1;</span><br><span class="line">                    int even &#x3D; m_FillOrigin &gt; 1 ? 1 : 0;</span><br><span class="line"></span><br><span class="line">                    if (m_FillOrigin &#x3D;&#x3D; 0 || m_FillOrigin &#x3D;&#x3D; 2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fy0 &#x3D; 0f;</span><br><span class="line">                        fy1 &#x3D; 1f;</span><br><span class="line">                        if (side &#x3D;&#x3D; even)</span><br><span class="line">                        &#123;</span><br><span class="line">                            fx0 &#x3D; 0f;</span><br><span class="line">                            fx1 &#x3D; 0.5f;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            fx0 &#x3D; 0.5f;</span><br><span class="line">                            fx1 &#x3D; 1f;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        fx0 &#x3D; 0f;</span><br><span class="line">                        fx1 &#x3D; 1f;</span><br><span class="line">                        if (side &#x3D;&#x3D; even)</span><br><span class="line">                        &#123;</span><br><span class="line">                            fy0 &#x3D; 0.5f;</span><br><span class="line">                            fy1 &#x3D; 1f;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            fy0 &#x3D; 0f;</span><br><span class="line">                            fy1 &#x3D; 0.5f;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    s_Xy[0].x &#x3D; Mathf.Lerp(v.x, v.z, fx0);</span><br><span class="line">                    s_Xy[1].x &#x3D; s_Xy[0].x;</span><br><span class="line">                    s_Xy[2].x &#x3D; Mathf.Lerp(v.x, v.z, fx1);</span><br><span class="line">                    s_Xy[3].x &#x3D; s_Xy[2].x;</span><br><span class="line"></span><br><span class="line">                    s_Xy[0].y &#x3D; Mathf.Lerp(v.y, v.w, fy0);</span><br><span class="line">                    s_Xy[1].y &#x3D; Mathf.Lerp(v.y, v.w, fy1);</span><br><span class="line">                    s_Xy[2].y &#x3D; s_Xy[1].y;</span><br><span class="line">                    s_Xy[3].y &#x3D; s_Xy[0].y;</span><br><span class="line"></span><br><span class="line">                    s_Uv[0].x &#x3D; Mathf.Lerp(tx0, tx1, fx0);</span><br><span class="line">                    s_Uv[1].x &#x3D; s_Uv[0].x;</span><br><span class="line">                    s_Uv[2].x &#x3D; Mathf.Lerp(tx0, tx1, fx1);</span><br><span class="line">                    s_Uv[3].x &#x3D; s_Uv[2].x;</span><br><span class="line"></span><br><span class="line">                    s_Uv[0].y &#x3D; Mathf.Lerp(ty0, ty1, fy0);</span><br><span class="line">                    s_Uv[1].y &#x3D; Mathf.Lerp(ty0, ty1, fy1);</span><br><span class="line">                    s_Uv[2].y &#x3D; s_Uv[1].y;</span><br><span class="line">                    s_Uv[3].y &#x3D; s_Uv[0].y;</span><br><span class="line"></span><br><span class="line">                    float val &#x3D; m_FillClockwise ? fillAmount * 2f - side : m_FillAmount * 2f - (1 - side);</span><br><span class="line"></span><br><span class="line">                    if (RadialCut(s_Xy, s_Uv, Mathf.Clamp01(val), m_FillClockwise, ((side + m_FillOrigin + 3) % 4)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        AddQuad(toFill, s_Xy, color, s_Uv);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (fillMethod &#x3D;&#x3D; FillMethod.Radial360)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int corner &#x3D; 0; corner &lt; 4; ++corner)</span><br><span class="line">                &#123;</span><br><span class="line">                    float fx0, fx1, fy0, fy1;</span><br><span class="line"></span><br><span class="line">                    if (corner &lt; 2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fx0 &#x3D; 0f;</span><br><span class="line">                        fx1 &#x3D; 0.5f;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        fx0 &#x3D; 0.5f;</span><br><span class="line">                        fx1 &#x3D; 1f;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (corner &#x3D;&#x3D; 0 || corner &#x3D;&#x3D; 3)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fy0 &#x3D; 0f;</span><br><span class="line">                        fy1 &#x3D; 0.5f;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        fy0 &#x3D; 0.5f;</span><br><span class="line">                        fy1 &#x3D; 1f;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    s_Xy[0].x &#x3D; Mathf.Lerp(v.x, v.z, fx0);</span><br><span class="line">                    s_Xy[1].x &#x3D; s_Xy[0].x;</span><br><span class="line">                    s_Xy[2].x &#x3D; Mathf.Lerp(v.x, v.z, fx1);</span><br><span class="line">                    s_Xy[3].x &#x3D; s_Xy[2].x;</span><br><span class="line"></span><br><span class="line">                    s_Xy[0].y &#x3D; Mathf.Lerp(v.y, v.w, fy0);</span><br><span class="line">                    s_Xy[1].y &#x3D; Mathf.Lerp(v.y, v.w, fy1);</span><br><span class="line">                    s_Xy[2].y &#x3D; s_Xy[1].y;</span><br><span class="line">                    s_Xy[3].y &#x3D; s_Xy[0].y;</span><br><span class="line"></span><br><span class="line">                    s_Uv[0].x &#x3D; Mathf.Lerp(tx0, tx1, fx0);</span><br><span class="line">                    s_Uv[1].x &#x3D; s_Uv[0].x;</span><br><span class="line">                    s_Uv[2].x &#x3D; Mathf.Lerp(tx0, tx1, fx1);</span><br><span class="line">                    s_Uv[3].x &#x3D; s_Uv[2].x;</span><br><span class="line"></span><br><span class="line">                    s_Uv[0].y &#x3D; Mathf.Lerp(ty0, ty1, fy0);</span><br><span class="line">                    s_Uv[1].y &#x3D; Mathf.Lerp(ty0, ty1, fy1);</span><br><span class="line">                    s_Uv[2].y &#x3D; s_Uv[1].y;</span><br><span class="line">                    s_Uv[3].y &#x3D; s_Uv[0].y;</span><br><span class="line"></span><br><span class="line">                    float val &#x3D; m_FillClockwise ?</span><br><span class="line">                        m_FillAmount * 4f - ((corner + m_FillOrigin) % 4) :</span><br><span class="line">                        m_FillAmount * 4f - (3 - ((corner + m_FillOrigin) % 4));</span><br><span class="line"></span><br><span class="line">                    if (RadialCut(s_Xy, s_Uv, Mathf.Clamp01(val), m_FillClockwise, ((corner + 2) % 4)))</span><br><span class="line">                        AddQuad(toFill, s_Xy, color, s_Uv);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            AddQuad(toFill, s_Xy, color, s_Uv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也用到了两组Vector3数组，<code>s_Xy</code>和<code>s_Uv</code>以复用和缓存临时变量。水平填充和竖直填充的类型比较简单，根据<code>m_FillOrigin</code>和<code>m_FillAmount</code>计算出来顶点坐标（<code>v</code>表示）和纹理坐标（<code>tx0</code>、<code>tx1</code>、<code>ty0</code>、<code>ty1</code>表示），顶点坐标和纹理坐标会分别被保存在<code>s_Xy</code>和<code>s_Uv</code>中。</p>
<p>这时候，如果满足条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_FillAmount &lt; 1f &amp;&amp; m_FillMethod !&#x3D; FillMethod.Horizontal &amp;&amp; m_FillMethod !&#x3D; FillMethod.Vertical</span><br></pre></td></tr></table></figure>

<p>则处理接下来的比较复杂的逻辑，否则直接使用<code>s_Xy</code>和<code>s_Uv</code>中保存的顶点坐标和纹理坐标绘制Quad：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void AddQuad(VertexHelper vertexHelper, Vector3[] quadPositions, Color32 color, Vector3[] quadUVs)</span><br><span class="line">&#123;</span><br><span class="line">    int startIndex &#x3D; vertexHelper.currentVertCount;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 4; ++i)</span><br><span class="line">        vertexHelper.AddVert(quadPositions[i], color, quadUVs[i]);</span><br><span class="line"></span><br><span class="line">    vertexHelper.AddTriangle(startIndex, startIndex + 1, startIndex + 2);</span><br><span class="line">    vertexHelper.AddTriangle(startIndex + 2, startIndex + 3, startIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>AddQuad</code>与前边的同名函数参数不同，但是所执行的功能是一致的。如果不幸满足了前边提到的条件，也即是说填充方式<code>m_FillMethod</code>是径向的90度<code>Radial90</code>、180度<code>Radial180</code>、360度<code>Radial360</code>并且<code>m_FillAmount</code>不等于1，那么就要根据具体情况划分为更多个Quad来处理了。使用<code>if else</code>搞了三个分支，依次分别处理90度、180度、360度的情况。</p>
<p>90度的情况用到了方法<code>RadialCut()</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static bool RadialCut(Vector3[] xy, Vector3[] uv, float fill, bool invert, int corner)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Nothing to fill</span><br><span class="line">    if (fill &lt; 0.001f) return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Even corners invert the fill direction</span><br><span class="line">    if ((corner &amp; 1) &#x3D;&#x3D; 1) invert &#x3D; !invert;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Nothing to adjust</span><br><span class="line">    if (!invert &amp;&amp; fill &gt; 0.999f) return true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Convert 0-1 value into 0 to 90 degrees angle in radians</span><br><span class="line">    float angle &#x3D; Mathf.Clamp01(fill);</span><br><span class="line">    if (invert) angle &#x3D; 1f - angle;</span><br><span class="line">    angle *&#x3D; 90f * Mathf.Deg2Rad;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Calculate the effective X and Y factors</span><br><span class="line">    float cos &#x3D; Mathf.Cos(angle);</span><br><span class="line">    float sin &#x3D; Mathf.Sin(angle);</span><br><span class="line"></span><br><span class="line">    RadialCut(xy, cos, sin, invert, corner);</span><br><span class="line">    RadialCut(uv, cos, sin, invert, corner);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据填充比例，如果小于<code>0.001f</code>直接不绘制，如果大于<code>0.999f</code>直接绘制全部。后边根据填充比例<code>fill</code>、填充方向是否<code>invert</code>（其实就是顺时针和逆时针方向），以及原点位置，来计算（修改）顶点坐标<code>xy</code>和纹理<code>uv</code>。使用的<code>RadialCut()</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">static void RadialCut(Vector3[] xy, float cos, float sin, bool invert, int corner)</span><br><span class="line">&#123;</span><br><span class="line">    int i0 &#x3D; corner;</span><br><span class="line">    int i1 &#x3D; ((corner + 1) % 4);</span><br><span class="line">    int i2 &#x3D; ((corner + 2) % 4);</span><br><span class="line">    int i3 &#x3D; ((corner + 3) % 4);</span><br><span class="line"></span><br><span class="line">    if ((corner &amp; 1) &#x3D;&#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sin &gt; cos)</span><br><span class="line">        &#123;</span><br><span class="line">            cos &#x2F;&#x3D; sin;</span><br><span class="line">            sin &#x3D; 1f;</span><br><span class="line"></span><br><span class="line">            if (invert)</span><br><span class="line">            &#123;</span><br><span class="line">                xy[i1].x &#x3D; Mathf.Lerp(xy[i0].x, xy[i2].x, cos);</span><br><span class="line">                xy[i2].x &#x3D; xy[i1].x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cos &gt; sin)</span><br><span class="line">        &#123;</span><br><span class="line">            sin &#x2F;&#x3D; cos;</span><br><span class="line">            cos &#x3D; 1f;</span><br><span class="line"></span><br><span class="line">            if (!invert)</span><br><span class="line">            &#123;</span><br><span class="line">                xy[i2].y &#x3D; Mathf.Lerp(xy[i0].y, xy[i2].y, sin);</span><br><span class="line">                xy[i3].y &#x3D; xy[i2].y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cos &#x3D; 1f;</span><br><span class="line">            sin &#x3D; 1f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!invert) xy[i3].x &#x3D; Mathf.Lerp(xy[i0].x, xy[i2].x, cos);</span><br><span class="line">        else xy[i1].y &#x3D; Mathf.Lerp(xy[i0].y, xy[i2].y, sin);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (cos &gt; sin)</span><br><span class="line">        &#123;</span><br><span class="line">            sin &#x2F;&#x3D; cos;</span><br><span class="line">            cos &#x3D; 1f;</span><br><span class="line"></span><br><span class="line">            if (!invert)</span><br><span class="line">            &#123;</span><br><span class="line">                xy[i1].y &#x3D; Mathf.Lerp(xy[i0].y, xy[i2].y, sin);</span><br><span class="line">                xy[i2].y &#x3D; xy[i1].y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (sin &gt; cos)</span><br><span class="line">        &#123;</span><br><span class="line">            cos &#x2F;&#x3D; sin;</span><br><span class="line">            sin &#x3D; 1f;</span><br><span class="line"></span><br><span class="line">            if (invert)</span><br><span class="line">            &#123;</span><br><span class="line">                xy[i2].x &#x3D; Mathf.Lerp(xy[i0].x, xy[i2].x, cos);</span><br><span class="line">                xy[i3].x &#x3D; xy[i2].x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cos &#x3D; 1f;</span><br><span class="line">            sin &#x3D; 1f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (invert) xy[i3].y &#x3D; Mathf.Lerp(xy[i0].y, xy[i2].y, sin);</span><br><span class="line">        else xy[i1].x &#x3D; Mathf.Lerp(xy[i0].x, xy[i2].x, cos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后经过一系列计算，更新<code>xy</code>和<code>uv</code>的值，绘制出Quad。180度的情况，需要将整个绘制区域分为两部分，并根据起点位置、填充方向等确定<code>fx0, fx1, fy0, fy1</code>这组参数来切割Image及纹理。最终转化为90度的问题来解决，360度填充也同理。</p>
<h3 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h3><p>前边大量篇幅都是在处理顶点（包括顶点坐标和顶点纹理坐标），接下来是材质，<code>Image</code>覆写了<code>Graphic</code>的方法<code>UpdateMaterial</code>，额外对<code>alphaTex</code>做了一些处理，即获取<code>activeSprite</code>是否有附带的alpha纹理（如ETC1格式的图片等），如果有的话就将这张alpha纹理传给<code>canvasRenderer</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected override void UpdateMaterial()</span><br><span class="line">&#123;</span><br><span class="line">    base.UpdateMaterial();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; check if this sprite has an associated alpha texture (generated when splitting RGBA &#x3D; RGB + A as two textures without alpha)</span><br><span class="line"></span><br><span class="line">    if (activeSprite &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        canvasRenderer.SetAlphaTexture(null);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Texture2D alphaTex &#x3D; activeSprite.associatedAlphaSplitTexture;</span><br><span class="line"></span><br><span class="line">    if (alphaTex !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        canvasRenderer.SetAlphaTexture(alphaTex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h2><p><code>Image</code>实现了接口<code>ILayoutElement</code>，因此可以作为自动布局元素。<code>Image</code>中主要是覆写了两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public virtual float preferredWidth</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        if (activeSprite &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        if (type &#x3D;&#x3D; Type.Sliced || type &#x3D;&#x3D; Type.Tiled)</span><br><span class="line">            return Sprites.DataUtility.GetMinSize(activeSprite).x &#x2F; pixelsPerUnit;</span><br><span class="line">        return activeSprite.rect.size.x &#x2F; pixelsPerUnit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public virtual float preferredHeight</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        if (activeSprite &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        if (type &#x3D;&#x3D; Type.Sliced || type &#x3D;&#x3D; Type.Tiled)</span><br><span class="line">            return Sprites.DataUtility.GetMinSize(activeSprite).y &#x2F; pixelsPerUnit;</span><br><span class="line">        return activeSprite.rect.size.y &#x2F; pixelsPerUnit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取<code>preferredWidth</code>和<code>preferredHeight</code>的具体实现，如果时Sliced或者Tiled，使用<code>Sprite</code>的MinSize，否则使用<code>rect</code>的尺寸。</p>
<h2 id="Raycast"><a href="#Raycast" class="headerlink" title="Raycast"></a>Raycast</h2><p><code>Image</code>实现了接口<code>ICanvasRaycastFilter</code>中的<code>IsRaycastLocationValid</code>方法，用于判断是否被射线射中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)</span><br><span class="line">&#123;</span><br><span class="line">    if (alphaHitTestMinimumThreshold &lt;&#x3D; 0)</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (alphaHitTestMinimumThreshold &gt; 1)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    if (activeSprite &#x3D;&#x3D; null)</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    Vector2 local;</span><br><span class="line">    if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Rect rect &#x3D; GetPixelAdjustedRect();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Convert to have lower left corner as reference point.</span><br><span class="line">    local.x +&#x3D; rectTransform.pivot.x * rect.width;</span><br><span class="line">    local.y +&#x3D; rectTransform.pivot.y * rect.height;</span><br><span class="line"></span><br><span class="line">    local &#x3D; MapCoordinate(local, rect);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Normalize local coordinates.</span><br><span class="line">    Rect spriteRect &#x3D; activeSprite.textureRect;</span><br><span class="line">    Vector2 normalized &#x3D; new Vector2(local.x &#x2F; spriteRect.width, local.y &#x2F; spriteRect.height);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Convert to texture space.</span><br><span class="line">    float x &#x3D; Mathf.Lerp(spriteRect.x, spriteRect.xMax, normalized.x) &#x2F; activeSprite.texture.width;</span><br><span class="line">    float y &#x3D; Mathf.Lerp(spriteRect.y, spriteRect.yMax, normalized.y) &#x2F; activeSprite.texture.height;</span><br><span class="line"></span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        return activeSprite.texture.GetPixelBilinear(x, y).a &gt;&#x3D; alphaHitTestMinimumThreshold;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (UnityException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(&quot;Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. &quot; + e.Message + &quot; Also make sure to disable sprite packing for this sprite.&quot;, this);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断特殊情况，<code>alphaHitTestMinimumThreshold</code>取0或者1，时就直接返回结果，否则需要做一系列了转换，得到射线射中位置的<code>a</code>即像素颜色的透明度，与<code>alphaHitTestMinimumThreshold</code>对比，如果大于等于则认为是有效（被射中）。</p>
<h2 id="接受序列化回调"><a href="#接受序列化回调" class="headerlink" title="接受序列化回调"></a>接受序列化回调</h2><p><code>Image</code>实现接口<code>ISerializationCallbackReceiver</code>，其中有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public virtual void OnBeforeSerialize() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public virtual void OnAfterDeserialize()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_FillOrigin &lt; 0)</span><br><span class="line">        m_FillOrigin &#x3D; 0;</span><br><span class="line">    else if (m_FillMethod &#x3D;&#x3D; FillMethod.Horizontal &amp;&amp; m_FillOrigin &gt; 1)</span><br><span class="line">        m_FillOrigin &#x3D; 0;</span><br><span class="line">    else if (m_FillMethod &#x3D;&#x3D; FillMethod.Vertical &amp;&amp; m_FillOrigin &gt; 1)</span><br><span class="line">        m_FillOrigin &#x3D; 0;</span><br><span class="line">    else if (m_FillOrigin &gt; 3)</span><br><span class="line">        m_FillOrigin &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    m_FillAmount &#x3D; Mathf.Clamp(m_FillAmount, 0f, 1f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在反序列化之后，对成员变量的值的有效性进行校正。</p>
<hr>
<p>本系列其它文章详见<a href="../2018-03-09-unity-3d-ugui-source-code-01">Unity3D UGUI 源码学习</a></p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://docs.unity3d.com/ScriptReference/Sprite.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Sprite.html</a></p>
<p><a href="https://docs.unity3d.com/ScriptReference/Sprites.DataUtility.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Sprites.DataUtility.html</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Unity3D/" rel="tag"># Unity3D</a>
              <a href="/tags/UGUI/" rel="tag"># UGUI</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/2018-07-02-osx-sed-remove-bom/" rel="prev" title="OSX使用sed移除UTF-8中的BOM">
      <i class="fa fa-chevron-left"></i> OSX使用sed移除UTF-8中的BOM
    </a></div>
      <div class="post-nav-item">
    <a href="/post/2018-07-26-unity-3d-ugui-source-code-11/" rel="next" title="Unity3D UGUI 源码学习 Text">
      Unity3D UGUI 源码学习 Text <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#用于显示图像：MaskableGraphic"><span class="nav-number">1.</span> <span class="nav-text">用于显示图像：MaskableGraphic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Geometry"><span class="nav-number">1.1.</span> <span class="nav-text">Geometry</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GenerateSimpleSprite"><span class="nav-number">1.1.1.</span> <span class="nav-text">GenerateSimpleSprite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GenerateSlicedSprite"><span class="nav-number">1.1.2.</span> <span class="nav-text">GenerateSlicedSprite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GenerateTiledSprite"><span class="nav-number">1.1.3.</span> <span class="nav-text">GenerateTiledSprite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GenerateFilledSprite"><span class="nav-number">1.1.4.</span> <span class="nav-text">GenerateFilledSprite</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Material"><span class="nav-number">1.2.</span> <span class="nav-text">Material</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动布局"><span class="nav-number">2.</span> <span class="nav-text">自动布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raycast"><span class="nav-number">3.</span> <span class="nav-text">Raycast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接受序列化回调"><span class="nav-number">4.</span> <span class="nav-text">接受序列化回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REFERENCE"><span class="nav-number">5.</span> <span class="nav-text">REFERENCE</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Aillieo</p>
  <div class="site-description" itemprop="description">PROGRAMMING | GAMES | DESIGN</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aillieo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'd4356b728d7738b0b7c9',
      clientSecret: '5258ccaf1be51bbe4467ac2c996d54b32602d41e',
      repo        : 'https://github.com/aillieo/aillieo.github.io',
      owner       : 'aillieo',
      admin       : [''],
      id          : '95e7248fef33af2f6a8e0ff70396f200',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
